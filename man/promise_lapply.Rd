% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{promise_lapply}
\alias{promise_lapply}
\title{Promise-aware lapply}
\usage{
promise_lapply(X, FUN, ...)
}
\arguments{
\item{X}{A vector (atomic or list) or an expression object (but not a
promise). Other objects (including classed objects) will be coerced by
base::as.list.}

\item{FUN}{The function to be applied to each element of \code{X}. The function is
permitted, but not required, to return a promise.}

\item{...}{Optional arguments to \code{FUN}.}
}
\description{
Similar to \code{\link[base:lapply]{base::lapply()}}, but promise-aware: the \code{FUN} function is
permitted to return promises, and while \code{lapply} returns a list,
\code{promises_lapply} returns a promise that resolves to a similar list (of
resolved values only, no promises).
}
\details{
\code{promise_lapply} processes elements of \code{X} serially; that is, if
\code{FUN(X[[1]])} returns a promise, then \code{FUN(X[[2]])} will not be invoked until
that promise is resolved. If any such promise rejects (errors), then the
promise returned by \code{promise_lapply} immediately rejects with that err.

[[1]: R:[1
[[2]: R:[2
}
\examples{
\dontrun{
# Waits x seconds, then returns x*10
wait_this_long <- function(x) {
  promise(~later::later(~{
    resolve(x*10)
  }, delay = x))
}

promise_lapply(list(A=1, B=2, C=3), wait_this_long) \%...>\%
  print()
}

}
