<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>An informal intro to async in R and Shiny • promises</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">promises</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/futures.html">Launching tasks with future</a>
    </li>
    <li>
      <a href="../articles/intro.html">An informal intro to async in R and Shiny</a>
    </li>
    <li>
      <a href="../articles/motivation.html">Motivation and limitations</a>
    </li>
    <li>
      <a href="../articles/shiny.html">Using promises with Shiny</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>An informal intro to async in R and Shiny</h1>
            
          </div>

    
    
<div class="contents">
<div id="an-informal-intro-to-async-in-r-and-shiny" class="section level1">
<h1 class="hasAnchor">
<a href="#an-informal-intro-to-async-in-r-and-shiny" class="anchor"></a>An informal intro to async in R and Shiny</h1>
<p>Hello, R and/or Shiny user! Let’s talk about async programming!</p>
<p><strong>Async programming? Sounds complicated.</strong></p>
<p>It is, very! You may want to grab some coffee.</p>
<p><strong>Ugh. Tell me why I even need to know this?</strong></p>
<p>Async programming is a major new addition to Shiny that can make certain classes of apps dramatically more responsive under load.</p>
<p>Because R is single threaded (i.e. it can only do one thing at a time), a given Shiny app process can also only do one thing at a time: if it is fitting a linear model for one client, it can’t simultaneously serve up a CSV download for another client.</p>
<p>For many Shiny apps, this isn’t a big problem; if no one processing step takes very long, then no client has to wait an undue amount of time before they start seeing results. But for apps that perform long-running operations — either expensive computations that take a while to complete, or waiting on slow network operations like database or web API queries — your users’ experience can suffer dramatically as traffic ramps up. Operations that normally are lightning quick, like downloading a small JavaScript file, can get stuck in traffic behind something slow.</p>
<p><strong>Oh, OK—more responsiveness is always good. But you said this’ll only help for certain classes of Shiny apps?</strong></p>
<p>It’s mostly helpful for apps that have a few specific operations that take a long time, rather than lots of little operations that are all a bit slow on their own and add up to one big slow mess. We’re looking for watermelons, not blueberries.</p>
<p><strong>Watermelons… sure. So then, how does this all work?</strong></p>
<p>It all starts with <em>async functions</em>. An async function is one that performs an operation that takes a long time, yet returns control to you immediately. Whereas a normal function like <code>read.csv</code> will not return until its work is done and it has the value you requested, a (hypothetical) <code>read.csv.async</code> function would kick off the CSV reading operation, but then return immediately, long before the real work has actually completed.</p>
<p><strong>So instead of “read this CSV file” it’s more like “begin reading this CSV file”?</strong></p>
<p>Yes! That’s what async functions do: they start things, and give you back a special object called a <em>promise</em>. If it doesn’t return a promise, it’s not an async function.</p>
<p><strong>Oh, I’ve heard of promises in R! From </strong><a href="http://adv-r.had.co.nz/Computing-on-the-language.html">the NSE chapter</a>** in Hadley’s Advanced R book!**</p>
<p>Ah… this is awkward, but no. I’m using the word “promise”, but I’m not referring to <em>that</em> kind of promise. For the purposes of async programming, try to forget that you’ve ever heard of that kind of promise, OK?</p>
<p>I know it seems needlessly confusing, but the promises we’re talking about here are shamelessly copied from directly inspired by a central abstraction in modern JavaScript, and the JS folks named them “promises”.</p>
<p><strong>Fine, whatever. So what are these promises?</strong></p>
<p>Conceptually, they’re a stand-in for the <em>eventual result</em> of the operation. For example, in the case of our (again, hypothetical) <code>read.csv.async</code> function, the promise is a stand-in for a data frame. At some point, the operation is going to finish, and a data frame is going to become available. The promise gives us a way to get at that value.</p>
<p><strong>Let me guess: it’s an object that has </strong><code>has_completed()</code>** and <strong><code>get_value()</code></strong> methods?**</p>
<p>Good guess, but no. Promises are <em>not</em> a way to directly inquire about the status of an operation, nor to directly retrieve the result value. That is probably the simplest and most obvious way to build an async framework, but in practice it’s very difficult to build deeply async programs with an API like that.</p>
<p>Instead, a promise lets you <em>chain together operations</em> that should be performed whenever the operation completes. These operations might have side effects (like plotting, or writing to disk, or printing to the console) or they might transform the result values somehow.</p>
<p><strong>Chain together operations? Using the <code>%&gt;%</code> operator?</strong></p>
<p>A lot like that! You can’t use the <code>%&gt;%</code> operator itself, but we provide a promise-compatible version of it: <code>%...&gt;%</code>. So whereas you might do this to a regular data frame:</p>
<pre><code>read.csv("data.csv") %&gt;%
  filter(state == "NY") %&gt;%
  arrange(median_income) %&gt;%
  head(10) %&gt;%
  View()</code></pre>
<p>The async version would look like:</p>
<pre><code>read.csv.async("data.csv") %...&gt;%
  filter(state == "NY") %...&gt;%
  arrange(median_income) %...&gt;%
  head(10) %...&gt;%
  View()</code></pre>
<p>The <code>%...&gt;%</code> operator here is the secret sauce. It’s called the <em>promise pipe</em>; the <code>...</code> stands for promise, and <code>&gt;</code> mimics the standard pipe operator.</p>
<p><strong>What a strange looking operator. Does it work just like a regular pipe?</strong></p>
<p>In many ways <code>%...&gt;%</code> does work like a regular pipe: it rewrites each stage’s function call to take the previous stage’s output as the first argument. (All the <a href="https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html">standard magrittr tricks</a> apply here: <code>.</code>, <code>{</code>, parenthesized lambdas, etc.) But the differences, while subtle, are profound.</p>
<p>The first and most important difference is that <code>%...&gt;%</code> <em>must</em> take a promise as input; that is, the left-hand side of the operator must be an expression that yields a promise. The <code>%...&gt;%</code> will do the work of “extracting” the result value from the promise, and passing that (unwrapped) result to the function call on the right-hand side.</p>
<p>This last fact—that <code>%...&gt;%</code> passes an unwrapped, plain old, not-a-promise value to the right-hand side—is critically important. It means we can use promise objects with non-promise-aware functions, with <code>%...&gt;%</code> serving as the bridge between asynchronous and synchronous code.</p>
<p><strong>So the left-hand side of <code>%...&gt;%</code> needs to be one of these special promise objects, but the right-hand side can be regular R base functions?</strong></p>
<p>Yes! R base functions, dplyr, ggplot2, or whatever.</p>
<p>However, that work often can’t be done in the present, since the whole point of a promise is that it represents work that hasn’t completed yet. So <code>%...&gt;%</code> does the work of extracting and piping not at the time that it’s called, but rather, sometime in the future.</p>
<p><strong>You lost me.</strong></p>
<p>OK, let’s slow down and take this step by step. We’ll generate a promise by calling an async function:</p>
<pre><code>df_promise &lt;- read.csv.async("data.csv")</code></pre>
<p>Even if <code>data.csv</code> is many gigabytes, <code>read.csv.async</code> returns immediately with a new promise. We store it as <code>df_promise</code>. Eventually, when the CSV reading operation successfully completes, the promise will contain a data frame, but for now it’s just an empty placeholder.</p>
<p>One thing we definitely <em>can’t</em> do is treat <code>df_promise</code> as if it’s simply a data frame:</p>
<pre><code><a href="http://dplyr.tidyverse.org/reference/filter.html"># Doesn't work!
dplyr::filter(df_promise, state == "NY")</a></code></pre>
<p>Try this and you’ll get an error like <code>no applicable method for 'filter_' applied to an object of class "promise"</code>. And the pipe won’t help you either; <code>df_promise %&gt;% filter(state == "NY")</code> will give you the same error.</p>
<p><strong>Right, that makes sense. </strong><code>filter</code>** is designed to work on data frames, and <strong><code>df_promise</code></strong> isn’t a data frame.**</p>
<p>Exactly. Now let’s try something that actually works:</p>
<pre><code>df_promise %...&gt;% filter(state == "NY")</code></pre>
<p>At the moment it’s called, this code won’t appear to do much of anything, really. But whenever the <code>df_promise</code> operation actually completes successfully, then the result of that operation—the plain old data frame—will be passed to <code>filter(., state = "NY")</code>.</p>
<p><strong>OK, so that’s good. I see what you mean about <code>%...&gt;%</code> letting you use non-promise functions with promises. But the whole point of using the </strong><code>filter</code>** function is to get a data frame back. If <strong><code>filter</code></strong> isn’t even going to be called until some random time in the future, how do we get its value back?**</p>
<p>I’ll tell you the answer, but it’s not going to be satisfying at first.</p>
<p>When you use a regular <code>%&gt;%</code>, the result you get back is the return value from the right-hand side:</p>
<pre><code>df_filtered &lt;- df %&gt;% filter(state == "NY")</code></pre>
<p>When you use <code>%...&gt;%</code>, the result you get back is a promise, whose <em>eventual</em> result will be the return value from the right-hand side:</p>
<pre><code>df_filtered_promise &lt;- df_promise %...&gt;% filter(state == "NY")</code></pre>
<p><strong>Wait, what? If I have a promise, I can do stuff to it using <code>%...&gt;%</code>, but then I just end up with another promise? Why not just have <code>%...&gt;%</code> return a regular value instead of a promise?</strong></p>
<p>Remember, the whole point of a promise is that we don’t know its value yet! So to write a function that uses a promise as input and returns some non-promise value as output, you’d need to either be a time traveler or an oracle.</p>
<p>To summarize, once you start working with a promise, any calculations and actions that are “downstream” of that promise will need to become promise-oriented. Generally, this means once you have a promise, you need to use <code>%...&gt;%</code> and keep using it until your pipeline terminates.</p>
<p><strong>I guess that makes sense. Still, if the only thing you can do with promises is make more promises, that limits their usefulness, doesn’t it?</strong></p>
<p>It’s a different way of thinking about things, to be sure, but it turns out there’s not much limit in usefulness—especially in the context of a Shiny app.</p>
<p>First, you can use promises with Shiny outputs. If you’re using an async-compatible version of Shiny (TODO: put version number), all of the built-in <code>renderXXX</code> functions can deal with either regular values or promises. An example of the latter:</p>
<pre><code>output$table &lt;- renderTable({
  read.csv.async("data.csv") %...&gt;%
    filter(state == "NY")
})</code></pre>
<p>When <code>output$table</code> executes the <code>renderTable</code> code block, it will notice that the result is a promise, and wait for it to complete before continuing with the table rendering. While it’s waiting, the R process can move on to do other things.</p>
<p>Second, you can use promises with reactive expressions. Reactive expressions treat promises about the same as they treat other values, actually. But this works perfectly fine:</p>
<pre><code># A reactive expression that returns a 
filtered_df &lt;- reactive({
  read.csv.async("data.csv") %...&gt;%
    filter(state == "NY") %...&gt;%
    arrange(median_income)
})

# A reactive expression that reads the previous
# (promise-returning) reactive, and returns a
# new promise
top_n_by_income &lt;- reactive({
  filtered_df() %...&gt;%
    head(input$n)
})

output$table &lt;- renderTable({
  top_n_by_income()
})</code></pre>
<p>Third, you can use promises in reactive observers. Use them to perform asynchronous tasks in response to reactivity.</p>
<pre><code>observeEvent(input$save, {
  filtered_df() %...&gt;%
    write.csv("ny_data.csv")
})</code></pre>
<p><strong>Alright, I think I see what you mean. You can’t escape from promise-land, but there’s no need to, because Shiny knows what to do with them.</strong></p>
<p>Yes, that’s basically right. You just need to keep track of which functions and reactive expressions return promises instead of regular values, and be sure to interact with them using <code>%...&gt;%</code> or other promise-aware operators and functions.</p>
<p><strong>Wait, there are other promise-aware operators and functions?</strong></p>
<p>Yes. The <code>%...&gt;%</code> is the one you’ll most commonly use, but there is a variant <code>%...T&gt;%</code>, which we call the <em>promise tee</em> operator (it’s analogous to the magrittr <code>%T&gt;%</code> operator). The <code>%...T&gt;%</code> operator mostly acts like <code>%...&gt;%</code>, but instead of returning a promise for the result value, it returns the original value instead. Meaning <code>p %...T&gt;% cat("\n")</code> won’t return a promise for the return value of <code>cat()</code> (which is always <code>NULL</code>) but instead the value of <code>p</code>. This is useful for logging, or other “side effecty” operations.</p>
<p>There’s also <code>%...!%</code>, and its tee version, <code>%...T!%</code>, which are used for error handling. I won’t confuse you with more about that now, but you can read more here. [TODO: link]</p>
<p>The <code>promises</code> package is where all of these operators live, and it also comes with some additional functions for working with promises.</p>
<p>So far, the only actual async function we’ve talked about has been <code>read.csv.async</code>, which doesn’t actually exist. To learn where actual async functions come from, read [TODO: link].</p>
<p>There are the lower-level functions <code>then</code>, <code>catch</code>, and <code>finally</code>, which are the non-pipe, non-operator equivalents of the promise operators we’ve been discussing. [TODO: link]</p>
<p>And finally, there are <code>promise_all</code> and <code>promise_race</code>, both used to combine multiple promises into a single promise. Learn more about them here. [TODO: link]</p>
<p><strong>OK, looks like I have a lot of stuff to read up on. And I’ll probably have to reread this conversation a few times before it fully sinks in.</strong></p>
<p>Sorry. I told you it was complicated. If you understand this guide, the one about error handling, and the one about creating promises, you’ll be 95% of the way there.</p>
<hr>
<p>TODO:</p>
<ul>
<li>read.csv.async is a terrible example, unless it could be implemented without data serialization. Change the example to something else — maybe downloading instead of reading/parsing.</li>
<li>Talk about how promise-pipe stages can themselves return promises (the “real” promise chaining).</li>
</ul>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#an-informal-intro-to-async-in-r-and-shiny">An informal intro to async in R and Shiny</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Joe Cheng.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
